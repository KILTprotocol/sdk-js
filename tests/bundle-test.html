<!DOCTYPE html>
<html>
  <head>
    <script src="./..//packages/sdk-js/dist/sdk-js.umd.js"></script>
    <script>
      const {
        Claim,
        Attestation,
        AttestedClaim,
        CType,
        RequestForAttestation,
        Did,
        BlockchainUtils,
        Utils: { Crypto, Keyring },
      } = kilt
    </script>
    <meta charset="UTF-8" />
    <title>Bundle tests</title>
    <style></style>
  </head>
  <body>
    <script async>
      // init sdk kilt config and connect to chain
      const keystore = new Did.DemoKeystore()
      const init = kilt.init({ address: 'ws://127.0.0.1:9944' })
      const blockchain = init.then(() => kilt.connect())

      blockchain.then((chain) => {
        if (!chain) console.error('No blockchain connection established')
        else chain.getStats().then((t) => console.log(t,0))
      })
      const keyring = new Keyring({ ss58Format: 38, type: 'ed25519' })
    </script>
    <script async>
      // Accounts
      const FaucetSeed =
        'receive clutch item involve chaos clutch furnace arrest claw isolate okay together'
      const devFaucet = keyring.createFromUri(FaucetSeed)
      const Alice = Did.createOnChainDidFromSeed(devFaucet, keystore, '//Alice')
      const Bob = Did.createOnChainDidFromSeed(devFaucet, keystore, '//Bob')
      const Charlie = Did.createOnChainDidFromSeed(
        devFaucet,
        keystore,
        '//Charlie'
      )
    </script>
    <script async>
      // Light Did Account creation workflow
      const authPublicKey = Crypto.coToUInt8(
        '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
      )
      const encPublicKey = Crypto.coToUInt8(
        '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb'
      )
      const address = Crypto.encodeAddress(authPublicKey, 38)
      const didCreationDetails = {
        authenticationKey: {
          publicKey: authPublicKey,
          type: 'ed25519',
        },
        encryptionKey: {
          publicKey: encPublicKey,
          type: 'x25519',
        },
      }
      const testDid = new Did.LightDidDetails(didCreationDetails)
      ;(testDid.did !==
        `did:kilt:light:01${address}:oWFlomlwdWJsaWNLZXlYILu7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7ZHR5cGVmeDI1NTE5` &&
        new Error('Did Test Unsuccessful')) ||
        console.log(
          `light did successfully created: ${JSON.stringify(testDid, null, 2)}`, 1
        )
    </script>
    <script async>
      // Chain Did workflow -> creation & deletion
      keystore
        .generateKeypair({
          alg: Did.SigningAlgorithms.Ed25519,
        })
        .then(({ publicKey, alg }) => {
          const didIdentifier = Crypto.encodeAddress(publicKey,38)
          const key = { publicKey, type: alg }
          Did.DidChain.generateCreateTx({
            didIdentifier,
            submitter: devFaucet.address,
            signer: keystore,
            signingPublicKey: key.publicKey,
            alg: key.type,
          })
            .then((tx) =>
              BlockchainUtils.signAndSubmitTx(tx, devFaucet, {
                resolveOn: BlockchainUtils.IS_IN_BLOCK,
              })
            )
            .then(() => {
              Did.DidChain.queryById(didIdentifier)
                .then(
                  (query) =>
                    (query.did ===
                      Did.DidUtils.getKiltDidFromIdentifier(
                        didIdentifier,
                        'full'
                      ) &&
                      console.log('Did Identifiers matching!', 2)) ||
                    new Error('Did Identifiers not matching!')
                )
                .then(() => {
                  Did.DidChain.getDeleteDidExtrinsic().then((extrinsic) => {
                    Did.DidChain.generateDidAuthenticatedTx({
                      submitter: devFaucet.address,
                      didIdentifier,
                      txCounter: 1,
                      call: extrinsic,
                      signer: keystore,
                      signingPublicKey: key.publicKey,
                      alg: key.type,
                    })
                      .then((submittable) =>
                        BlockchainUtils.signAndSubmitTx(
                          submittable,
                          devFaucet,
                          {
                            resolveOn: BlockchainUtils.IS_IN_BLOCK,
                          }
                        )
                      )
                      .then(() =>
                        Did.DidChain.queryById(didIdentifier).then(
                          (didResult) =>
                            didResult === null &&
                            console.log('Did successfully deleted!', 3)
                        )
                      )
                  })
                })
            })
        })
    </script>
    <script async>
      // CType workflow
      const DriversLicense = CType.fromSchema({
        $id: 'kilt:ctype:0x1',
        $schema: 'http://kilt-protocol.org/draft-01/ctype#',
        title: 'Drivers License',
        properties: {
          name: {
            type: 'string',
          },
          age: {
            type: 'integer',
          },
        },
        type: 'object',
      })

      Alice.then((alice) => {
        Did.DidChain.queryById(alice.identifier).then(
          (chainDid) =>
            (!chainDid && console.log('Alice Did on chain!')) ||
            new Error('did not created')
        )
        DriversLicense.store()
          .then((tx) => alice.authorizeExtrinsic(tx, keystore, devFaucet.address))
          .then((tx) =>
            BlockchainUtils.signAndSubmitTx(tx, devFaucet, {
              resolveOn: BlockchainUtils.IS_IN_BLOCK,
              reSign: true,
            })
          )
          .then(() => {
            DriversLicense.verifyStored().then(
              (stored) =>
                (stored &&
                  console.log('CType successfully stored onchain!', 4)) ||
                new Error('ctype not stored!')
            )
            kilt.CTypeUtils.verifyOwner({
              ...DriversLicense,
              owner: alice.did,
            }).then(
              (result) =>
                (result && console.log('owner verified', 5)) ||
                new Error('ctype owner does not match ctype creator did')
            )
          })
      })
    </script>
    <script async>
      //Attestation workflow

      const content = { name: 'Bob', age: 21 }
      Promise.all([Alice, Bob]).then(([alice, bob]) => {
        const claim = Claim.fromCTypeAndClaimContents(
          DriversLicense,
          content,
          bob.did
        )
        const request = RequestForAttestation.fromClaim(claim)
        request.signWithDid(keystore, bob).then((signed) => {
          RequestForAttestation.isIRequestForAttestation(signed) &&
            ((signed.verifyData() && console.log('Req4Att data verified', 6)) ||
              new Error('Req4Att not verifiable')) &&
            ((signed.verifySignature() &&
              console.log('Req4Att signature verified', 7)) ||
              new Error('Req4Att Signature mismatch')) &&
            signed.claim.contents !== content &&
            new Error('Claim content inside Req4Att mismatching')
          const attestation = Attestation.fromRequestAndDid(signed, alice.did)
          const aClaim = AttestedClaim.fromRequestAndAttestation(
            signed,
            attestation
          )
          ;(aClaim.verifyData() &&
            console.log('Attested Claim Data verified!', 8)) ||
            new Error('Attested Claim data not verifiable')
          attestation
            .store()
            .then((tx) => alice.authorizeExtrinsic(tx, keystore, devFaucet.address))
            .then((tx) =>
              BlockchainUtils.signAndSubmitTx(tx, devFaucet, {
                resolveOn: BlockchainUtils.IS_IN_BLOCK,
                reSign: true,
              }).then(
                (aClaim.verify() &&
                  console.log('Attested Claim verified with chain.', 9)) ||
                  new Error('attested Claim not verifiable with chain')
              )
            )
        })
      })
    </script>
    <script async></script>
  </body>
</html>
